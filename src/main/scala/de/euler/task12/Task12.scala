package de.euler.task12

import scala.math._


//The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

//1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

//Let us list the factors of the first seven triangle numbers:

// 1: 1
// 3: 1,3
// 6: 1,2,3,6
//10: 1,2,5,10
//15: 1,3,5,15
//21: 1,3,7,21
//28: 1,2,4,7,14,28
//We can see that 28 is the first triangle number to have over five divisors.

//What is the value of the first triangle number to have over five hundred divisors?

class Task12{

  def solve():Any = {
    val triangles = Stream.iterate((1,1)){
      x => (x._1 +1, x._2+x._1+1) 
    }
//    val result = for(tr <- triangles;
//      divisors = for (i  <- 1 to (tr._2 / 2); if(tr._2 % i == 0)) yield i
//      if(divisors.length +1> 500)
//      ) yield (tr,divisors.toList)

    val result = -1
    
    for(tr <- triangles){
      var divisors = 0;
      for (i  <- 1 to (tr._2 / 2)){
        if(tr._2 % i == 0)
          divisors += 1
      }
      if (divisors +1> 500) return tr
    }
    return -1
  }
  
  
  def isPrime(num:Long) : Boolean = {
    for(t <- 2 to sqrt(num.toDouble).toInt; if(num % t == 0)) return false
    return true
  }
  
   def nextPrime(start:Long):Stream[Long] = {
       isPrime(start) match {
           case false => nextPrime(start+1L)
           case true => Stream.cons(start, nextPrime(start+1L))
       }
   }

  val primeList:Stream[Long] = nextPrime(2L)
  def factor(num:Long, factors:Map[Long,Long] = Map()):Map[Long,Long] = {
      primeList takeWhile(_ <= num) find(num%_ == 0) match {
          case None => factors
          case Some(x) => factors.get(x) match {
            case None => factor(num/x, factors + (x -> 1))
            case Some(times) => factor(num/x, factors - (x) + (x -> (times +1)))
          }
      }
  }
         
  
  def solveAlt():Any = {
    var firstPrimes :Map[Long,Long]= Map.empty
    for(first <- Stream.from(1)){
      val second = first+1
      val secondPrimes = factor(second)
      val combinedPrimes = (secondPrimes ++ firstPrimes)
      val trianglePrimes = combinedPrimes - 2 + (2L -> (combinedPrimes(2)-1))
      val triangleDivisors = (for(prime <- trianglePrimes.filter(_._2 > 0)) yield prime._2+1).product  
      if(triangleDivisors > 500)
        return (first, (first*second)/2)
      firstPrimes = secondPrimes      
    }
    return -1
  }
   
}